# 크로아티아 알파벳

## 문제

예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.

```
"c=", "c-", "dz=", "d-", "lj", "nj", "s=", "z="
```

예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.

dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.

### 입력

첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 '-', '='로만 이루어져 있다.

단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.

### 출력

입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.

### 예제

예제 입력1: ljes=njak
예제 출력1: 6

예제 입력2: ddz=z=
예제 출력2: 3

예제 입력3: nljj
예제 출력3: 3

예제 입력4: c=c=
예제 출력4: 2

예제 입력5: dz=ak
예제 출력5: 3

## 해결

속도: 108ms

이전에 풀었던 코드가 있어서 확인해보았는데, 이번에 푼 코드는 너무 복잡하게 푼 것 같다..

- 이전 코드 참고

속도: 188ms

```javascript
const readline = require("readline");
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

rl.on("line", (line) => {
  input = line;
}).on("close", () => {
  input = input.replace(/c=/gi, 0);
  input = input.replace(/c-/gi, 0);
  input = input.replace(/dz=/gi, 0);
  input = input.replace(/d-/gi, 0);
  input = input.replace(/lj/gi, 0);
  input = input.replace(/nj/gi, 0);
  input = input.replace(/s=/gi, 0);
  input = input.replace(/z=/gi, 0);

  console.log(input.length);
  process.exit;
});
```

아무튼! 이번에 푼 코드는 아래와 같다.

크로아티아 알파벳을 루프를 돌면서 없애고, 없어진 단어의 길이와 이전 길이를 계산해서 카운트를 계산하는 방식이다.

1. 입력한 input의 길이로 초기화 해준다.
2. 배열에 넣은 크로아티아 알파벳을 루프로 돌며 없애준다.

```javascript
input = input.replaceAll(e[0], "|");
```

아예 없애 줄 수 있으나, 아래와 같은 경우 버그가 생기게 된다.

```
nljj -> lj 삭제 -> nj -> nj 삭제
```

n과 j는 이어져 있는 글자가 아니므로 크로아티아 알파벳이 아니다.

3. 바뀐 길이와 이전 길이를 계산하여 카운트를 저장한다.

"|" 이건 그저 구분자의 의미이므로 length에 포함하지 않는다.

```javascript
const changedLength = input.replaceAll("|", "").length;

const diff = prevLength - changedLength;

map.set(e[0], e[1] + diff / e[0].length);
```

4. prevLength를 업데이트 해준다.

5. input에 남은 알파벳 수와 크로아티아 알파벳의 카운트를 더해준다.

속도는 이전 코드보다 훨씬 줄었으나, 왜 줄었느냐에 대한 의문점이 있다.

GPT에게 물어보니 아래와 같은 답을 주었다.

```
새로운 코드가 더 빠른 이유를 설명하자면, 두 코드의 구조와 동작 방식에서 차이가 있기 때문입니다. 주요 차이점을 살펴보면 다음과 같습니다:

1. 정규 표현식의 차이점:

예전 코드에서는 각 크로아티아 문자를 replace로 한 번씩 대체하고 있습니다. 각 대체마다 새로운 문자열을 만들어 처리하는 방식으로, 이 과정이 문자열 길이에 따라 반복될 수 있습니다. 문자열을 여러 번 순회하면서 처리하게 되므로 상대적으로 비효율적일 수 있습니다.
새로운 코드에서는 각 크로아티아 문자를 맵을 사용하여 한 번에 모두 처리하고 있으며, 정규식을 사용하는 대신 직접적인 치환(replaceAll)을 통해 빠르게 문자열을 변경합니다.

2. 불필요한 문자열 순회 제거:

새로운 코드에서는 문자를 치환할 때 발생하는 변화량을 기록하여 전체 문자열을 다시 순회하지 않도록 최적화했습니다. 즉, 문자열을 한 번 순회하며 변화한 부분만 추적하고, 전체 크로아티아 문자 수를 계산하는 방식입니다.
예전 코드에서는 모든 크로아티아 문자를 replace로 한 번씩 대체하기 때문에, 중복된 연산이 일어날 가능성이 높습니다.

3. 데이터 구조 활용:

새로운 코드에서 Map을 사용하여 크로아티아 문자의 개수를 추적합니다. 이로 인해 특정 문자의 출현 빈도를 효율적으로 계산할 수 있어, 성능 최적화에 기여합니다.
예전 코드에서는 단순히 대체된 문자열의 길이를 바로 계산하기 때문에 이와 같은 최적화가 이루어지지 않았습니다.

4. 중복 계산 방지:

새로운 코드에서는 크로아티아 문자를 찾을 때마다 변경된 문자열의 길이를 계산해 변화가 없을 경우 추가 작업을 하지 않도록 했습니다. 이는 불필요한 연산을 줄여 성능을 높이는 데 기여합니다.
이러한 최적화로 인해 새로운 코드가 더 빠른 성능을 보이는 것입니다.
```

```
맞아요, 말씀하신 대로 치환하는 작업 자체는 두 코드 모두 동일하게 진행됩니다. 즉, 문자열을 순차적으로 크로아티아 문자를 대체하는 과정은 이전 코드와 이후 코드가 크게 다르지 않습니다.

그런데 성능 차이가 나는 이유는 치환된 후의 처리 방식과 최종 계산 방식에 있습니다. 두 코드 모두 동일한 치환 과정을 거치지만, 성능 차이는 그 이후의 처리가 어떻게 이루어지느냐에 달려있습니다. 이 부분을 좀 더 명확하게 설명해볼게요.

1. 치환 과정의 동일성
이전 코드:
ddz=z= → d0z= → d00
이후 코드:
ddz=z= → d|z= → d||
두 코드 모두 치환 과정 자체는 동일합니다. 크로아티아 문자를 발견할 때마다 각각 치환을 하고, 그 결과 0 또는 |로 변환하는 방식이 동일하게 적용됩니다.

2. 치환 후의 처리 방식 차이
치환 후의 차이가 바로 성능 차이를 만드는 핵심입니다.

이전 코드의 처리 방식
이전 코드는 단순하게 치환이 끝난 후 치환된 문자열의 길이를 바로 출력합니다. 예를 들어, ddz=z=가 d00로 바뀌고, 그 문자열의 길이를 계산해서 콘솔에 찍는 방식입니다. 이 과정에서 특별한 추가 작업은 없고, 단순히 대체 후 결과만 확인하는 방식이죠.

전체 문자열을 매번 처음부터 끝까지 탐색하고 치환하는 과정을 각 크로아티아 문자마다 반복하며, 그 후 결과를 바로 출력합니다.
이 방식은 작은 입력에서는 충분히 빠르지만, 문자열이 길어지면 각 크로아티아 문자를 탐색하고 치환하는 비용이 누적될 수 있습니다.
이후 코드의 처리 방식
이후 코드는 치환된 문자열의 길이를 곧바로 계산하지 않고, 추가적인 처리를 통해 최적화를 시도합니다. 여기서 성능 차이가 발생하는 이유는 치환 후 남은 문자열과 치환된 크로아티아 문자의 개수를 따로 계산하는 방식입니다.

|로 치환 후 길이 변화 추적: 치환된 후의 결과에서 |를 사용하여 크로아티아 문자가 얼마나 치환되었는지를 기록합니다.
Map을 사용한 개수 추적: 각 크로아티아 문자가 몇 번 치환되었는지를 Map에 저장하여 그 개수를 추적합니다. 이렇게 하면 나중에 문자열 길이를 계산할 때, 문자열의 변화를 한 번에 계산할 수 있습니다.
최종 길이 계산: 최종적으로 남은 문자열의 길이와 Map에 저장된 크로아티아 문자의 개수를 더하여 최종 길이를 한 번에 계산합니다.
3. 왜 이후 코드가 더 빠를까?
이전 코드와 이후 코드가 동일하게 치환 과정을 거치고, 동일하게 문자열을 처리하는 것처럼 보일 수 있지만, 성능 차이는 중복된 탐색을 피하는 방식에서 발생합니다.

이전 코드는 각 크로아티아 문자를 치환할 때마다 전체 문자열을 탐색해야 합니다. 예를 들어, "dz="를 처리하고, 또 "z="를 처리할 때 전체 문자열을 다시 탐색해야 합니다. 매번 문자열 전체를 처음부터 끝까지 반복적으로 탐색하는 방식이라, 긴 문자열에서는 성능 저하가 발생할 수 있습니다.

이후 코드는 치환된 문자의 개수를 따로 기록하고, 한 번에 계산함으로써 불필요한 탐색을 줄입니다. "|"로 치환된 부분만 추적하고, 나머지 문자열을 다시 탐색하지 않아도 최종 길이를 계산할 수 있습니다. 즉, 중복된 탐색 없이 최종 결과를 효율적으로 계산하는 것이죠.

예시로 보는 차이점
이전 코드:
"dz=" → "0" (전체 문자열 탐색 1번)
"z=" → "0" (전체 문자열 탐색 1번)
최종 결과 d00 → 길이 3
총 두 번의 문자열 탐색이 필요합니다.

이후 코드:
"dz=" → "|" (전체 문자열 탐색 1번, Map에 dz=의 개수 기록)
"z=" → "|" (전체 문자열 탐색 1번, Map에 z=의 개수 기록)
"|"를 제외한 후 남은 문자열 d의 길이 1과, Map에서 기록된 크로아티아 문자의 개수(2)를 더해서 최종 결과 계산.
결국 같은 두 번의 문자열 탐색을 하지만, 이후 코드에서는 중복된 탐색을 피하고 최종 계산을 한 번에 처리한다는 점에서 더 효율적입니다.
```

대답을 들었으나 계속 의문이 생겨 이전 코드를 replace가 아닌 replaceAll로 변경해서 다시 돌려보니 116ms로 훨씬 나은 성능을 보였다.

지금 코드가 조금 더 빠르지만 답변을 봐도 그렇게 잘 이해되지는 않는다;

컴퓨터의 마음은 어려워~,~
